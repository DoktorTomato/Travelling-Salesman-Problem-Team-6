# Travelling-Salesman-Problem-Team-6
Комп'ютерний проєкт з дискретної математики тема 6 "Задача комівояжера" від команди 6 <br />
Звіт <br /> 
**Розподіл роботи:**
- Шевчук Іван - precise_alg()
- Канцир Катерина - read_csv(), робота над презентацією
- Сеньків Софія - робота над презентацією
- Кеда Роксоляна - greedy_alg()
- Тебенько Ярема - звіт  <br /> 
Спільна праця та допомога з усіма функціями від кожного члена компанії
<br /> 
**Функція read_file:** <br />
Функція read_file призначена для зчитування *.csv файлу, що містить граф, та повертає дані у форматі словника, де ключі представляють вершини, а значення - список суміжних вершин із їх вагами <br />
<br />
•	Відкриваємо файл у режимі читання ('r') та зчитуємо його вміст за допомогою read().splitlines() для отримання списку рядків. <br />
•	Далі кожен рядок розділяється за комами за допомогою split(','), створюючи таким чином список списків. <br />
•	Створюємо порожній словник ‘new_dict’, де ключі відповідають вершинам графа, а значення - спискам кортежів (вершина, вага). <br />
•	Проходимо через отриманий вміст та наповнюємо словник: <br />
•	Якщо вершина ще не існує у словнику, створюємо новий ключ із списком, що містить кортеж із наступною вершиною та вагою. <br />
o	Якщо вершина вже існує у словнику, додаємо новий кортеж із наступною вершиною та вагою до відповідного списку. <br />
o	Перетворюємо ваги вершин у цілі числа, оскільки зчитані дані завжди мають формат рядка. <br />
•	Повертаємо отриманий словник, де ключі - це вершини графа, а значення - списки кортежів із суміжними вершинами та їх вагами. <br />
**Функція precise_alg:** <br />
Функція precise_alg вирішує задачу комівояжера точним алгоритмом (Held-Karp algorithm). <br />
Підготовчі процеси: <br />
•	Перевіряємо чи наша програма запущена вперше, і якщо так, вся пам’ять про шляхи очищується <br />
•	Створюємо неіснуючі ребра ( які з’єднюють кожну вершину з всіма решта) і присвоюється їм нескінченно велика відстань. <br />
Основна частина: <br />
•	Запускаємо перевірку на наявність у списку ‘go_through’ (список вершин, які треба відвідати) елементів. <br />
•	Якщо він порожній, то значить всі вершини, вже  не треба відвідувати крім  початкової  і кінцевої.    Якщо результат для набору вершин уже збережений у пам’яті ‘memo’ то він одразу ж буде повернений, інакше відбувається рекурсивний виклик для знаходження найкращого шляху для поточного набору вершин. <br />
•	Якщо у ньому є елементи, це означає, що є ще невідвідані вершини. Алгоритм рекурсивно викликає сам себе для кожної вершини з ‘go_through’. Обчислюються значення ‘val1’ і ‘val2’, що представляють відстані для подолання від ‘city’ до ‘dest’ і від ‘start’ до ‘city’ відповідно. Формується шлях, який включає в себе ці вершини, і результат додається до списку ‘routes’. Найкращий шлях визначається як той, який має мінімальну вагу, і результат повертається як кортеж (вага, шлях) <br />
•	У кінці функції формується ключ ‘the_way’ для збереження у пам'яті ‘memo’ результатів рекурсивних викликів для даного набору вершин. Результат обчислення (вага шляху та шлях) зберігається у ‘memo’ і повертається як результат функції. <br />
<br />
**greedy_alg:** <br />
•	Створюємо список ‘path’, в який додаватимуться відвідані вершини й ‘current_point’, змінну яка відображає поточну вершину <br />
•	Запускаємо цикл, який триватиме поки всі вершини графа не будуть відвідані. <br />
o	При кожній ітерації ініціалзуємо мінімальну відстать між точками як нескінченність і наступну точку як None. <br />
o	Ітеруємо значення в словнику за поточною вершиною, як ключ. <br />
	Перевіряємо чи кожна сусідня вершина вже є у відвіданих і чи відстань з ними є менша за мінімальну відстань і якщо так, то оновлюємо мінімальну відстань і наступну точку. <br />
o	Перевіряємо чи залишились у нас невідвідані точки і якщо так, то зупиняємо цикл <br />
o	Додаємо знайденого сусіда до відвіданих вершин і оновлюємо поточну вершину <br />
•	Вертаємо  список відвіданих точок <br />


